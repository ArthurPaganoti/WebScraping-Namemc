<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/__main__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/__main__.py" />
              <option name="originalContent" value="import time&#10;import json&#10;import requests&#10;import re&#10;import random&#10;from playwright.sync_api import sync_playwright, TimeoutError as PlaywrightTimeoutError&#10;&#10;&#10;class NameMCScraper:&#10;    &quot;&quot;&quot;&#10;    Uma classe para automatizar a extração de nomes do NameMC,&#10;    contornando o desafio Cloudflare Turnstile com técnicas aprimoradas.&#10;    &quot;&quot;&quot;&#10;    BASE_URL = &quot;https://pt.namemc.com/minecraft-names?offset=3196800&amp;sort=desc&quot;&#10;    CAPSOLVER_KEY = &quot;CAP-F5238D35CBD407280A722AEC24E62FB22B065F6412A88E3A1E4A254AD7049B36&quot;&#10;    USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36'&#10;&#10;    def __init__(self, headless=False):&#10;        &quot;&quot;&quot;&#10;        Inicializa o scraper.&#10;        :param headless: True para rodar o navegador em segundo plano, False para vê-lo.&#10;        &quot;&quot;&quot;&#10;        self.headless = headless&#10;        self.playwright = None&#10;        self.browser = None&#10;        self.page = None&#10;&#10;    def _solve_captcha(self, sitekey):&#10;        &quot;&quot;&quot;&#10;        Envia o sitekey para o Capsolver e retorna o token de solução.&#10;        (Método privado)&#10;        &quot;&quot;&quot;&#10;        print(f&quot;Enviando sitekey para o Capsolver...&quot;)&#10;        payload = {&#10;            &quot;clientKey&quot;: self.CAPSOLVER_KEY,&#10;            &quot;task&quot;: {&#10;                &quot;type&quot;: &quot;AntiTurnstileTaskProxyLess&quot;,&#10;                &quot;websiteKey&quot;: sitekey,&#10;                &quot;websiteURL&quot;: self.BASE_URL,&#10;            }&#10;        }&#10;        try:&#10;            response = requests.post(&quot;https://api.capsolver.com/createTask&quot;, json=payload, timeout=20)&#10;            response.raise_for_status()&#10;            task_id = response.json().get(&quot;taskId&quot;)&#10;            if not task_id:&#10;                print(f&quot;❌ Erro ao criar tarefa no Capsolver: {response.text}&quot;)&#10;                return None&#10;        except requests.RequestException as e:&#10;            print(f&quot;❌ Erro de conexão com Capsolver: {e}&quot;)&#10;            return None&#10;&#10;        print(f&quot;Tarefa Capsolver criada: {task_id}. Aguardando solução...&quot;)&#10;        start_time = time.time()&#10;        while time.time() - start_time &lt; 90:  # Timeout de 90s&#10;            time.sleep(3)&#10;            try:&#10;                res = requests.post(&quot;https://api.capsolver.com/getTaskResult&quot;,&#10;                                    json={&quot;clientKey&quot;: self.CAPSOLVER_KEY, &quot;taskId&quot;: task_id}, timeout=20)&#10;                res.raise_for_status()&#10;                data = res.json()&#10;                if data.get(&quot;status&quot;) == &quot;ready&quot;:&#10;                    print(&quot;✅ Token recebido do Capsolver!&quot;)&#10;                    return data[&quot;solution&quot;].get(&quot;token&quot;)&#10;                if data.get(&quot;status&quot;) == &quot;failed&quot; or data.get(&quot;errorId&quot;):&#10;                    print(f&quot;❌ Falha ao resolver captcha: {res.text}&quot;)&#10;                    return None&#10;            except requests.RequestException:&#10;                continue&#10;        print(&quot;❌ Timeout esperando a solução do Capsolver.&quot;)&#10;        return None&#10;&#10;    def _extract_sitekey(self):&#10;        &quot;&quot;&quot;&#10;        Espera pelo widget do Turnstile e extrai o sitekey.&#10;        (Método privado)&#10;        &quot;&quot;&quot;&#10;        print(&quot;Procurando pelo sitekey do Cloudflare Turnstile...&quot;)&#10;        try:&#10;            # Salva o HTML da página para depuração antes de buscar o iframe&#10;            html = self.page.content()&#10;            with open('debug_page.html', 'w', encoding='utf-8') as f:&#10;                f.write(html)&#10;            print(&quot;HTML salvo em 'debug_page.html' para análise.&quot;)&#10;            # Aumentamos o timeout e esperamos pelo iframe específico do desafio.&#10;            print(&quot;Aguardando o widget do Turnstile carregar (até 20s)...&quot;)&#10;            iframe_selector = 'iframe[src*=&quot;challenges.cloudflare.com/turnstile&quot;]'&#10;            self.page.wait_for_selector(iframe_selector, timeout=20000)&#10;            print(&quot;Widget (iframe) encontrado! Extraindo a sitekey...&quot;)&#10;&#10;            # Assim que o iframe estiver presente, o contêiner com o data-sitekey também deve estar.&#10;            sitekey = self.page.locator('div.cf-turnstile').get_attribute('data-sitekey')&#10;            if sitekey:&#10;                print(f&quot;✅ Sitekey encontrado: {sitekey}&quot;)&#10;                return sitekey&#10;        except PlaywrightTimeoutError:&#10;            print(&quot;❌ Timeout! O widget do Turnstile não apareceu na página.&quot;)&#10;            self.page.screenshot(path='debug_no_widget.png')&#10;            print(&quot;Screenshot 'debug_no_widget.png' salva para análise.&quot;)&#10;            return None&#10;        return None&#10;&#10;    def _wait_js_challenge(self):&#10;        &quot;&quot;&quot;&#10;        Aguarda o desafio JS do Cloudflare ser resolvido automaticamente.&#10;        &quot;&quot;&quot;&#10;        print(&quot;Aguardando o desafio JS do Cloudflare ser resolvido...&quot;)&#10;        try:&#10;            # Espera até que o título da página mude de &quot;Um momento…&quot; ou o texto de verificação suma ou a URL mude&#10;            self.page.wait_for_function(&#10;                &quot;document.title !== 'Um momento…' || !document.body.innerText.includes('Verificando se você é humano') || window.location.pathname !== '/minecraft-names'&quot;,&#10;                timeout=90000&#10;            )&#10;            print(&quot;Desafio JS resolvido, continuando...&quot;)&#10;        except PlaywrightTimeoutError:&#10;            print(&quot;⚠️ Timeout esperando o desafio JS do Cloudflare. Pode não ter sido resolvido.&quot;)&#10;&#10;    def scrape_names(self):&#10;        &quot;&quot;&quot;&#10;        Orquestra o processo completo de scraping com técnicas anti-detecção.&#10;        &quot;&quot;&quot;&#10;        with sync_playwright() as p:&#10;            self.playwright = p&#10;            print(&quot;Iniciando navegador Chrome...&quot;)&#10;            try:&#10;                self.browser = self.playwright.chromium.launch(headless=self.headless, channel=&quot;chrome&quot;)&#10;            except Exception:&#10;                print(&quot;⚠️ Chrome não encontrado. Usando o Chromium padrão.&quot;)&#10;                self.browser = self.playwright.chromium.launch(headless=self.headless)&#10;&#10;            context = self.browser.new_context(&#10;                user_agent=self.USER_AGENT,&#10;                locale='pt-BR',&#10;                viewport={&quot;width&quot;: 1920, &quot;height&quot;: 1080},&#10;                java_script_enabled=True,&#10;                extra_http_headers={&#10;                    &quot;accept-language&quot;: &quot;pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7&quot;,&#10;                    &quot;accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;,&#10;                    &quot;referer&quot;: &quot;https://pt.namemc.com/&quot;&#10;                }&#10;            )&#10;            self.page = context.new_page()&#10;&#10;            print(&quot;Injetando script 'stealth.js' para evitar detecção...&quot;)&#10;            self.page.add_init_script(path='stealth.js')&#10;&#10;            print(f&quot;Navegando para: {self.BASE_URL}&quot;)&#10;            try:&#10;                # 2. Espera a página carregar completamente, incluindo todos os recursos (imagens, scripts).&#10;                self.page.goto(self.BASE_URL, wait_until='load', timeout=60000)&#10;            except PlaywrightTimeoutError:&#10;                print(&quot;⚠️ Timeout ao carregar a página, mas o script continuará a tentativa.&quot;)&#10;&#10;            # Aguarda o JS Challenge do Cloudflare ser resolvido&#10;            self._wait_js_challenge()&#10;&#10;            # 3. Simula uma interação humana antes de procurar o desafio.&#10;            print(&quot;Simulando interação humana para ativar scripts...&quot;)&#10;            self.page.wait_for_timeout(random.randint(2000, 3500))  # Pausa de 2 a 3.5 segundos&#10;            self.page.mouse.move(x=random.randint(150, 600), y=random.randint(150, 400))&#10;            self.page.wait_for_timeout(random.randint(1000, 2000))&#10;&#10;            sitekey = self._extract_sitekey()&#10;            if not sitekey:&#10;                self.close()&#10;                return&#10;&#10;            token = self._solve_captcha(sitekey)&#10;            if not token:&#10;                self.close()&#10;                return&#10;&#10;            print(&quot;Injetando token de solução na página...&quot;)&#10;            self.page.evaluate(f&quot;&quot;&quot;&#10;                document.querySelector('[name=&quot;cf-turnstile-response&quot;]').value = '{token}';&#10;            &quot;&quot;&quot;)&#10;            self.page.wait_for_timeout(2000)  # Pequena pausa para o script da página processar o token&#10;&#10;            print(&quot;Aguardando o Cloudflare validar o token e redirecionar...&quot;)&#10;            try:&#10;                self.page.wait_for_function(&quot;document.querySelector('a.card-title') !== null&quot;, timeout=60000)&#10;                print(&quot;✅ Página de conteúdo carregada após o bypass!&quot;)&#10;            except PlaywrightTimeoutError:&#10;                print(&quot;❌ Timeout: A página não carregou o conteúdo após injetar o token.&quot;)&#10;                self.page.screenshot(path='falha_bypass.png')&#10;                self.close()&#10;                return&#10;&#10;            print(&quot;Extraindo nomes da página...&quot;)&#10;            nomes = self.page.eval_on_selector_all('a.card-title', 'els =&gt; els.map(e =&gt; e.textContent.trim())')&#10;            if nomes:&#10;                print(f&quot;✅ Sucesso! {len(nomes)} nomes foram encontrados.&quot;)&#10;                with open('nomes.json', 'w', encoding='utf-8') as f:&#10;                    json.dump(nomes, f, ensure_ascii=False, indent=2)&#10;                print(&quot;Dados salvos em 'nomes.json'.&quot;)&#10;            else:&#10;                print(&quot;❌ Falha. Nenhum nome encontrado na página final.&quot;)&#10;&#10;            self.close()&#10;&#10;    def close(self):&#10;        &quot;&quot;&quot;Fecha o navegador e os recursos do Playwright.&quot;&quot;&quot;&#10;        if self.browser:&#10;            print(&quot;Fechando navegador...&quot;)&#10;            self.browser.close()&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Para rodar e ver o navegador, use: scraper = NameMCScraper(headless=False)&#10;    # Para rodar em segundo plano, use: scraper = NameMCScraper(headless=True)&#10;    scraper = NameMCScraper(headless=False)&#10;    scraper.scrape_names()&#10;" />
              <option name="updatedContent" value="import time&#10;import json&#10;import requests&#10;import re&#10;import random&#10;from playwright.sync_api import sync_playwright, TimeoutError as PlaywrightTimeoutError&#10;&#10;&#10;class NameMCScraper:&#10;    &quot;&quot;&quot;&#10;    Uma classe para automatizar a extração de nomes do NameMC,&#10;    contornando o desafio Cloudflare Turnstile com técnicas aprimoradas.&#10;    &quot;&quot;&quot;&#10;    BASE_URL = &quot;https://pt.namemc.com/minecraft-names?offset=3196800&amp;sort=desc&quot;&#10;    CAPSOLVER_KEY = &quot;CAP-F5238D35CBD407280A722AEC24E62FB22B065F6412A88E3A1E4A254AD7049B36&quot;&#10;    USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36'&#10;&#10;    def __init__(self, headless=False):&#10;        &quot;&quot;&quot;&#10;        Inicializa o scraper.&#10;        :param headless: True para rodar o navegador em segundo plano, False para vê-lo.&#10;        &quot;&quot;&quot;&#10;        self.headless = headless&#10;        self.playwright = None&#10;        self.browser = None&#10;        self.page = None&#10;&#10;    def _solve_captcha(self, sitekey):&#10;        &quot;&quot;&quot;&#10;        Envia o sitekey para o Capsolver e retorna o token de solução.&#10;        (Método privado)&#10;        &quot;&quot;&quot;&#10;        print(f&quot;Enviando sitekey para o Capsolver...&quot;)&#10;        payload = {&#10;            &quot;clientKey&quot;: self.CAPSOLVER_KEY,&#10;            &quot;task&quot;: {&#10;                &quot;type&quot;: &quot;AntiTurnstileTaskProxyLess&quot;,&#10;                &quot;websiteKey&quot;: sitekey,&#10;                &quot;websiteURL&quot;: self.BASE_URL,&#10;            }&#10;        }&#10;        try:&#10;            response = requests.post(&quot;https://api.capsolver.com/createTask&quot;, json=payload, timeout=20)&#10;            response.raise_for_status()&#10;            task_id = response.json().get(&quot;taskId&quot;)&#10;            if not task_id:&#10;                print(f&quot;❌ Erro ao criar tarefa no Capsolver: {response.text}&quot;)&#10;                return None&#10;        except requests.RequestException as e:&#10;            print(f&quot;❌ Erro de conexão com Capsolver: {e}&quot;)&#10;            return None&#10;&#10;        print(f&quot;Tarefa Capsolver criada: {task_id}. Aguardando solução...&quot;)&#10;        start_time = time.time()&#10;        while time.time() - start_time &lt; 90:  # Timeout de 90s&#10;            time.sleep(3)&#10;            try:&#10;                res = requests.post(&quot;https://api.capsolver.com/getTaskResult&quot;,&#10;                                    json={&quot;clientKey&quot;: self.CAPSOLVER_KEY, &quot;taskId&quot;: task_id}, timeout=20)&#10;                res.raise_for_status()&#10;                data = res.json()&#10;                if data.get(&quot;status&quot;) == &quot;ready&quot;:&#10;                    print(&quot;✅ Token recebido do Capsolver!&quot;)&#10;                    return data[&quot;solution&quot;].get(&quot;token&quot;)&#10;                if data.get(&quot;status&quot;) == &quot;failed&quot; or data.get(&quot;errorId&quot;):&#10;                    print(f&quot;❌ Falha ao resolver captcha: {res.text}&quot;)&#10;                    return None&#10;            except requests.RequestException:&#10;                continue&#10;        print(&quot;❌ Timeout esperando a solução do Capsolver.&quot;)&#10;        return None&#10;&#10;    def _extract_sitekey(self):&#10;        &quot;&quot;&quot;&#10;        Espera pelo widget do Turnstile e extrai o sitekey.&#10;        (Método privado)&#10;        &quot;&quot;&quot;&#10;        print(&quot;Procurando pelo sitekey do Cloudflare Turnstile...&quot;)&#10;        try:&#10;            # Salva o HTML da página para depuração antes de buscar o iframe&#10;            html = self.page.content()&#10;            with open('debug_page.html', 'w', encoding='utf-8') as f:&#10;                f.write(html)&#10;            print(&quot;HTML salvo em 'debug_page.html' para análise.&quot;)&#10;            # Aumentamos o timeout e esperamos pelo iframe específico do desafio.&#10;            print(&quot;Aguardando o widget do Turnstile carregar (até 20s)...&quot;)&#10;            iframe_selector = 'iframe[src*=&quot;challenges.cloudflare.com/turnstile&quot;]'&#10;            self.page.wait_for_selector(iframe_selector, timeout=20000)&#10;            print(&quot;Widget (iframe) encontrado! Extraindo a sitekey...&quot;)&#10;&#10;            # Assim que o iframe estiver presente, o contêiner com o data-sitekey também deve estar.&#10;            sitekey = self.page.locator('div.cf-turnstile').get_attribute('data-sitekey')&#10;            if sitekey:&#10;                print(f&quot;✅ Sitekey encontrado: {sitekey}&quot;)&#10;                return sitekey&#10;        except PlaywrightTimeoutError:&#10;            print(&quot;❌ Timeout! O widget do Turnstile não apareceu na página.&quot;)&#10;            self.page.screenshot(path='debug_no_widget.png')&#10;            print(&quot;Screenshot 'debug_no_widget.png' salva para análise.&quot;)&#10;            return None&#10;        return None&#10;&#10;    def _wait_js_challenge(self):&#10;        &quot;&quot;&quot;&#10;        Aguarda o desafio JS do Cloudflare ser resolvido automaticamente.&#10;        &quot;&quot;&quot;&#10;        print(&quot;Aguardando o desafio JS do Cloudflare ser resolvido...&quot;)&#10;        try:&#10;            # Espera até que o JS do Cloudflare libere o acesso (aguarda sumir o texto e aparecer conteúdo real)&#10;            self.page.wait_for_function(&#10;                &quot;!document.body.innerText.includes('Verificando se você é humano') &amp;&amp; document.querySelector('input[name=\'cf-turnstile-response\']') === null&quot;,&#10;                timeout=120000&#10;            )&#10;            print(&quot;Desafio JS resolvido, continuando...&quot;)&#10;        except PlaywrightTimeoutError:&#10;            print(&quot;⚠️ Timeout esperando o desafio JS do Cloudflare. Pode não ter sido resolvido.&quot;)&#10;&#10;    def scrape_names(self):&#10;        &quot;&quot;&quot;&#10;        Orquestra o processo completo de scraping com técnicas anti-detecção.&#10;        &quot;&quot;&quot;&#10;        with sync_playwright() as p:&#10;            self.playwright = p&#10;            print(&quot;Iniciando navegador Chrome...&quot;)&#10;            try:&#10;                self.browser = self.playwright.chromium.launch(headless=self.headless, channel=&quot;chrome&quot;)&#10;            except Exception:&#10;                print(&quot;⚠️ Chrome não encontrado. Usando o Chromium padrão.&quot;)&#10;                self.browser = self.playwright.chromium.launch(headless=self.headless)&#10;&#10;            context = self.browser.new_context(&#10;                user_agent=self.USER_AGENT,&#10;                locale='pt-BR',&#10;                viewport={&quot;width&quot;: 1920, &quot;height&quot;: 1080},&#10;                java_script_enabled=True,&#10;                extra_http_headers={&#10;                    &quot;accept-language&quot;: &quot;pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7&quot;,&#10;                    &quot;accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;,&#10;                    &quot;referer&quot;: &quot;https://pt.namemc.com/&quot;&#10;                }&#10;            )&#10;            self.page = context.new_page()&#10;&#10;            print(&quot;Injetando script 'stealth.js' para evitar detecção...&quot;)&#10;            self.page.add_init_script(path='stealth.js')&#10;&#10;            print(f&quot;Navegando para: {self.BASE_URL}&quot;)&#10;            try:&#10;                # 2. Espera a página carregar completamente, incluindo todos os recursos (imagens, scripts).&#10;                self.page.goto(self.BASE_URL, wait_until='load', timeout=60000)&#10;            except PlaywrightTimeoutError:&#10;                print(&quot;⚠️ Timeout ao carregar a página, mas o script continuará a tentativa.&quot;)&#10;&#10;            # Aguarda o JS Challenge do Cloudflare ser resolvido&#10;            self._wait_js_challenge()&#10;&#10;            # 3. Simula uma interação humana antes de procurar o desafio.&#10;            print(&quot;Simulando interação humana para ativar scripts...&quot;)&#10;            self.page.wait_for_timeout(random.randint(2000, 3500))  # Pausa de 2 a 3.5 segundos&#10;            self.page.mouse.move(x=random.randint(150, 600), y=random.randint(150, 400))&#10;            self.page.wait_for_timeout(random.randint(1000, 2000))&#10;&#10;            sitekey = self._extract_sitekey()&#10;            if not sitekey:&#10;                self.close()&#10;                return&#10;&#10;            token = self._solve_captcha(sitekey)&#10;            if not token:&#10;                self.close()&#10;                return&#10;&#10;            print(&quot;Injetando token de solução na página...&quot;)&#10;            self.page.evaluate(f&quot;&quot;&quot;&#10;                document.querySelector('[name=&quot;cf-turnstile-response&quot;]').value = '{token}';&#10;            &quot;&quot;&quot;)&#10;            self.page.wait_for_timeout(2000)  # Pequena pausa para o script da página processar o token&#10;&#10;            print(&quot;Aguardando o Cloudflare validar o token e redirecionar...&quot;)&#10;            try:&#10;                self.page.wait_for_function(&quot;document.querySelector('a.card-title') !== null&quot;, timeout=60000)&#10;                print(&quot;✅ Página de conteúdo carregada após o bypass!&quot;)&#10;            except PlaywrightTimeoutError:&#10;                print(&quot;❌ Timeout: A página não carregou o conteúdo após injetar o token.&quot;)&#10;                self.page.screenshot(path='falha_bypass.png')&#10;                self.close()&#10;                return&#10;&#10;            print(&quot;Extraindo nomes da página...&quot;)&#10;            nomes = self.page.eval_on_selector_all('a.card-title', 'els =&gt; els.map(e =&gt; e.textContent.trim())')&#10;            if nomes:&#10;                print(f&quot;✅ Sucesso! {len(nomes)} nomes foram encontrados.&quot;)&#10;                with open('nomes.json', 'w', encoding='utf-8') as f:&#10;                    json.dump(nomes, f, ensure_ascii=False, indent=2)&#10;                print(&quot;Dados salvos em 'nomes.json'.&quot;)&#10;            else:&#10;                print(&quot;❌ Falha. Nenhum nome encontrado na página final.&quot;)&#10;&#10;            self.close()&#10;&#10;    def close(self):&#10;        &quot;&quot;&quot;Fecha o navegador e os recursos do Playwright.&quot;&quot;&quot;&#10;        if self.browser:&#10;            print(&quot;Fechando navegador...&quot;)&#10;            self.browser.close()&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Para rodar e ver o navegador, use: scraper = NameMCScraper(headless=False)&#10;    # Para rodar em segundo plano, use: scraper = NameMCScraper(headless=True)&#10;    scraper = NameMCScraper(headless=False)&#10;    scraper.scrape_names()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>